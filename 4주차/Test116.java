/*=======================================
  ■■■ 클래스 고급 ■■■
  - 상속 관계에 있는 클래스들 간의 캐스팅
    (업 캐스팅, 다운 캐스팅)
=======================================*/

// super class, 부모 클래스, 상위 클래스
class SuperTest116
{
	public int a = 10, b = 20;

	public void write()
	{
		System.out.println("슈퍼클래스 write() 메소드...");
	}

	public int hap()
	{
		return a + b;
	}
}

// sub class, 자식 클래스, 하위 클래스
class SubTest116 extends SuperTest116
{
	public int b = 100, c = 200;

	@Override
	public int hap()
	{
		return a + b + c;
	}

	public void print()
	{
		System.out.println("서브클래스 print() 메소드...");
	}
}


// main() 메소드를 포함하는 외부의 다른 클래스
public class Test116
{
	public static void main(String[] args)
	{
		// 하위 클래스 기반 인스턴스 생성
		SubTest116 ob1 = new SubTest116();

		System.out.println("ob1.b : " + ob1.b);
		//== ob1.b : 100 // 덮어쓰기
		
		// ○ 업 캐스팅
		SuperTest116 ob2 = ob1;
		// SuperTest116 ob2 = (SuperTest116)ob1; 과 동일한 코드
		/*
		학생 홍길동 = new 학생();

		포유류 사람 = 홍길동;		// 포유류 사람 = (사람)홍길동; 과 동일한 코드

		학생도 포유류

		class 포유류			class 학생 extends 포유류
		{						{
		}						}

		*/

		System.out.println("ob2.b : " + ob2.b);
		//System.out.println("ob2.b : " + ((SuperTest116)ob1).b);
		//== ob2.b : 20
		// 메모리 그림판에서 변수는 객체별로 따로 할당되기 때문에
		// 변수 b는 ob2(부모객체)의 변수이다.
		
		System.out.println("합	: " + ob2.hap());
		//== 합      : 310
		// hap() 메소드는 오버라이딩(Overriding) 되어 있고
		// ob2(부모)는 ob1(자식)을 업캐스팅한 상태의 객체이므로
		// SuperTest116의 hap() 메소드를 호출하는 것이 아니라
		// SubTest에서 재정의한 hap() 메소드를 호출하게 된다.
		// 즉, 메소드는 
		// 업 캐스팅이 되더라도 
		// 재정의(덮어쓰기)한 이상 원래의 기능으로 되돌릴 수 없다.

		ob2.write(); // 오버라이딩안해서 부모설계도 write나온다
		//== 슈퍼클래스 write() 메소드...

		// ob2.print();         부모자료형으로 업캐스팅된 상황이라 자식설계도에 있는 메소드 못쓴다.
		//== 컴파일 에러


		// ○ 다운 캐스팅
		((SubTest116)ob2).print();			//자식자료형으로 다운캐스팅
		// 서브클래스 print() 메소드...

		// 추가 관찰 ------------------------------------------------------------------------
		// 다운 캐스팅 가능 여부
		
		// 상위 클래스 기반 인스턴스 생성
		SuperTest116 ob3 = new SuperTest116();
		
		SubTest116 ob4;

		//System.out.println(ob3.c);	// 상위 클래스에는 c가 없다 == 하위 클래스가 있다는 걸 모른다
		//== 컴파일 에러
		// 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.
		// (상위 객체 입장에서는 어떤 하위 객체가 존재하는지도 알 수 없음)

		//ob4 = ob3;
		//== 컴파일 에러
		// 상위 객체는 하위 객체에 담을 수(참조할 수) 없다.

		//ob4 = (SubTest116)ob3;
		//== ClassCastException 런타임에러
		// 자식클래스 인스턴스 생성시 상속받는 부모클래스도 메모리에 올라가지만 
		// 부모클래스 인스턴스 생성시 자식클래스는 메모리에 올라가지 않는다(자식클래스가 한두개가 아닐 가능성이 크기 때문)
		// 그렇기 때문에 상위클래스 객체를 강제로 하위 클래스로 형 변환을 하게되면 컴파일은 되지만 런타임에러가 난다.

		// 작성된 구문의 문법적인 구조만 봤을 때 이 구문은 다운 캐스팅이 이루어지는 상황이다.
		// 하지만, 정상적인 캐스팅이 이루어지지 않는다. 현재 SubTest116 객체에 대한 메모리 할당은 이루어지지 않은 상태이기 때문
		// 그러므로, 이 상황에서 다운 캐스팅은 불가능하다.

/*
○ 업 캐스팅, 다운 캐스팅이 정상적으로 이루어지는 경우 ---------------------------------------------\
   
   1. 하위 객체 생성;		// 체크
   2. 상위 = 하위;			// 업캐스팅   -> 가능
   3. 하위 = 상위;			// 에러 발생
   4. 하위 = (하위)상위;	// 다운캐스팅 -> 가능
	
○ 다운 캐스팅이 정상적으로 이루어지지 않는 경우---------------------------------------
   
   1. 상위 객체 생성;		// 체크
   2. 하위 = 상위;			// 에러 발생
   3. 하위 = (하위)상위;	// 다운 캐스팅 but 런타임 에러

 업 캐스팅은 항상 가능, 다운 캐스팅은 경우에 따라 가능.

	}
}